<!DOCTYPE html>
<html>
<head>
	<title></title>
	<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <link href="/css/bootstrap.min.css" rel="stylesheet">
    <style>
      img{
      	width: 50px;
      	height: 50px;
      }
      #shoppingCart{
        position: fixed;
        z-index: 1;
        top: 40%;
        left: 60%;
      }
      #searchProduct{
        display: flex;
        justify-content: center;
      }
	</style>
</head>
<body>
  
  <!--This view will change depending on whether the user is logged in or not-->
  <nav class="navbar navbar-dark bg-dark">
  <div class="container-fluid">
     <a href="/customer/catalogue">Catalogo</a>
     <a href="/customer/purchases">Tus transacciones</a>
     <a href="/customer/account-settings">Configuracion de la cuenta</a>
     <a href="/customer/logout">Salir</a>
  </div>
</nav>

<button type="button" class="btn btn-success" id="shoppingCart" data-bs-toggle="modal" data-bs-target="#cart">Tu compra</button>

<div id="root"></div>

<script src="/js/bootstrap.bundle.min.js"></script>

<script crossorigin src="https://unpkg.com/react@17/umd/react.development.js"></script>
<script crossorigin src="https://unpkg.com/react-dom@17/umd/react-dom.development.js"></script>
<script src="https://unpkg.com/babel-standalone@6/babel.min.js"></script>

<script type="text/babel">
  /*Creo la clase "informacion bancaria" que contendra la informacion respectiva a las cuentas bancarias y metodos de pago del comercio
  que este viendo el usuario, para que al momento de pagar, el usuario pueda ver las distintas opciones*/
  /*Por cierto, dejare este comentario para recordar al momento de empezar a trabajar de nuevo:
  Lo que me falta hacer es sincronizar los eventos de agregar un item al carrito, el evento de compra del componente en forma de modal
  purchase y mostrar la informacion financiera en ese mismo componente. */
  const eventBus={
    on(event, callback){
      document.addEventListener(event, (e) => callback(e.detail));
    },
    dispatch(event, data){
      document.dispatchEvent(new CustomEvent(event, { detail: data }));
    }
  }

  class paymentInformation{
    constructor(){
      this.data=[]
    }

    async getData(){
      let request=await fetch('/customer/catalogue/payment-information', {method: 'GET', headers: 
        {'Content-Type': 'application/json'}})
      let response=await request.json()
      if (response.message==='Sucessfull operation'){
        /*Because not necessary some commerce use all the payment methods, I will filter what methods are use knowing the value
        of the referenceNumber. If is '', then is not used*/
        let paymentMethodsData=response.result[0].paymentInformation //This is not a string... is a object, so, JSON.parse is innecesary
        paymentMethodsData.forEach(method=>{
          if (method.referenceNumber!==''){
            this.data.push(method)
          } 
        })
      }
      return this.data
    }
  }
  async function getProducts(){
    let request=await fetch('/customer/catalogue/products', {method: 'GET', headers: {'Content-Type': 'application/json'}});
    let response=await request.json();
    return {products: response.result};
  }

  (async function test(){
    
    class Item extends React.Component {
      constructor(props){
        super(props)
        this.addToCart=this.addToCart.bind(this)
        this.state={
          addToCartButtonColor: 'btn btn-warning'
        }
      }

      addToCart(){
        //I change the color of the botton (changin the state color, a class of the button) for like 0.5 seconds
        this.setState({
          addToCartButtonColor: 'btn btn-primary'
        })
        setTimeout(()=>this.setState({addToCartButtonColor: 'btn btn-warning'}), 250)
        //This will fire the event "addItem" of the shopping cart component. 
        /*The propsobject is not extensible, so, I send a new object with the props of interest, not the this.props, because,
        the property amount will be necessary in the shopping cart component*/
        let itemData={name: this.props.name, price: this.props.price, src: this.props.src}
        eventBus.dispatch('addItem', itemData)
      }

      render(){
        return(
          <li className="list-group-item">
            <p>Nombre: {this.props.name}</p>
            <p>Cantidad disponible: {this.props.availableQuantity}</p>
            <p>Precio: {this.props.price}</p>
            <img src={this.props.src} alt='Foto del producto'/>
           <button type="button" className={this.state.addToCartButtonColor} onClick={this.addToCart} id="addToCart">Agregar al carrito</button>
          </li>
        )
      }
    }

    class SearchProduct extends React.Component {
      constructor(props){
        super(props)
        this.state={
          characters: ''
        }
        this.searchProductsInTheList=this.searchProductsInTheList.bind(this)
      }

      async searchProductsInTheList(event){
        await this.setState({characters: event.target.value})
        eventBus.dispatch('searchProducts', {characters: this.state.characters})
      }

      render(){
        return(
          <div id="searchProduct">
            <input value={this.state.characters} onChange={this.searchProductsInTheList} type="search" aria-label="Search" placeholder="Buscar producto"/>
          </div>
        )
      }
    }

    class List extends React.Component {
      constructor(props){
        super(props)
        this.state={
          products: this.props.products
        }
      }
      componentDidMount(){
        eventBus.on('searchProducts', data=>{
          const characters=new RegExp(`^${data.characters}`)
          let result=[]
          this.props.products.forEach(product=>{
            if (characters.test(product.productName)){
              result.push(product)
            }
          })
          this.setState({products: result})
        })
      }

      render(){
        return (
          <ul className="list-group">{this.state.products.map((product)=>{
           return <Item key={product.productName} 
           name={product.productName} 
           availableQuantity={product.availableQuantity}
           price={product.price}
           src={product.productPhotoPath}/>
          })}</ul>
        )
      }
    }

    class ShoppingCart extends React.Component {
      constructor(props){
        super(props)
        this.addItem=this.addItem.bind(this)
        this.deleteItem=this.deleteItem.bind(this)
        this.state={
          items: [],
          totalPrice: 0
        }
      }

      componentDidMount(){
        eventBus.on('addItem', data =>{
          this.addItem(data)
        })
        eventBus.on('sendPurchaseData', data=>{
          let productsData=this.state.items
          eventBus.dispatch('receiveProductsDataFromTheShoppingCart', productsData)
        })
        eventBus.on('sucessfullPurchase', data=>{
          //The user has buyed the items, so, the shopping cart now is empty
          this.setState({
            items: []
          })
        })
      }

      addItem(item){
        //First, I check if the product exist in the cart. In the case that exist, the amount of that item up to +1
        let i=0, flag=false, itemIndex=-1
        while (i<this.state.items.length && !flag){
          if (this.state.items[i].name===item.name){
            flag=true
            itemIndex=i
          }
          i++
        }
        let newItemsValue=this.state.items
        if (!flag){
          item.amount=1
          newItemsValue.push(item)
          this.setState({
            items: newItemsValue
          })
        } else{
          newItemsValue[itemIndex].amount+=1
          this.setState({
            items: newItemsValue
          })
        }
        //I calculate the total price again
        let newTotalPrice=0
        this.state.items.forEach(item=>{
          newTotalPrice+=parseInt(item.amount)*parseInt(item.price)
        })
        this.setState({ 
          totalPrice: newTotalPrice
        })
        /*Next, I update the total price in the purchase modal.
        Btw, setState is asyncrhonous. For that, I send the newTotalPrice, not the state*/
        eventBus.dispatch('updateTotalPrice', {newPrice: newTotalPrice}) 
      }

      async deleteItem(itemName){
        //I get the index of the item in the array state, and I update from that
        let i=0, flag=false, itemIndex=-1
        while (i<this.state.items.length || !flag){
          if (this.state.items[i].name===itemName){
            flag=true
            itemIndex=i
          }
          i++
        }
        let newItemsValue=[]
        for (let i=0; i<this.state.items.length; i++){
          if (i!==itemIndex){
            newItemsValue.push(this.state.items[i])
          }
        }
        await this.setState({
          items: newItemsValue
        })
        //I calculate the total price again
        let newTotalPrice=0
        this.state.items.forEach(item=>{
          newTotalPrice+=parseInt(item.amount)*parseInt(item.price)
        })
        await this.setState({ 
          totalPrice: newTotalPrice
        })
        eventBus.dispatch('updateTotalPrice', {newPrice: this.state.totalPrice}) 
      }

      buy(){ //Just show the purchase modal
      }

      render(){
        return (
            <div className="modal fade" id="cart" tabIndex="-1" aria-labelledby="exampleModalLabel" aria-hidden="true">
            <div className="modal-dialog">
            <div className="modal-content">
            <div className="modal-header">
            <h5 className="modal-title" id="exampleModalLabel">Carrito de compra</h5>
            <button type="button" className="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
          </div>
          <div className="modal-body" id="cartBody">
            <table className="table">
              <thead>
                <tr>
                  <th>Producto</th><th>Precio</th><th>Cantidad</th>
                </tr>
              </thead>
              <tbody>
                {this.state.items.map(item=>{
                  return <tr key={item.name}>
                           <td>{item.name}</td><td>{item.price}</td><td>{item.amount}</td><td><img src={item.src}/></td><td><button onClick={()=>this.deleteItem(item.name)} className="btn btn-danger">Quitar</button></td>
                         </tr>
                })}
              </tbody>
            </table>
          </div>
          <div className="modal-footer">
            <button type="button" className="btn btn-primary" id="buy" data-bs-dismiss="modal" data-bs-toggle="modal" data-bs-target="#purchase" onClick={this.buy}>Comprar</button>
            <button type="button" className="btn btn-danger" data-bs-dismiss="modal">Cerrar</button>
          </div>
          </div>
          </div>
          </div>
        )
      }
    }

    class Purchase extends React.Component{
      constructor(props){
        super(props)
        this.confirm=this.confirm.bind(this)
        this.transaction=this.transaction.bind(this)
        this.changeMethodName=this.changeMethodName.bind(this)
        this.changeReferenceNumber=this.changeReferenceNumber.bind(this)
        /*The user is free to change his payment method, yes, but the initial value will be the first of the shop.
        For two reasons: If the store only has one method, then the user will not be able to execute the change action, and then the value will never change. Even if there are more than two, but the user never changes, the value will remain null, since the value of the payment method will still depend on whether or not the user changes the method.*/
        this.state={
          totalPrice: 0,
          methodName: this.props.paymentMethods[0].name,
          referenceNumber: ''
        }
      }
  
      changeMethodName(event){
        this.setState({
          methodName: event.target.value
        })
      }

      changeReferenceNumber(event){
        this.setState({
          referenceNumber: event.target.value
        })
      }

     /*-El evento confirmar del componente purchase, disparara el evento sendPurchaseData del componente shopping cart
       -El evento sendPurchaseData activara el evento receiveProductsDataFromTheShoppingCart del componente purchase
       -El evento receiveProductsDataFromTheShoppingCart activara el evento transaction del componente purchase
       -Finalmente, el evento transaction sera una solicitud fetch para registrar una compra del cliente en la respectiva tienda*/

      confirm(){
        eventBus.dispatch('sendPurchaseData', null)
      }

      componentDidMount(){
        eventBus.on('updateTotalPrice', data=>{
          this.setState({
            totalPrice: data.newPrice
          })
        })
        eventBus.on('receiveProductsDataFromTheShoppingCart', data=>{
          //First I obtain the total price (just multiply the price of each item with the amount, and sum, duhhh)
          /*let totalPrice=0
          data.forEach(item=>{
            totalPrice+=parseInt(item.amount)*parseInt(item.price)
          })
          data.totalPrice=totalPrice*/
          this.transaction(data)
        })
      }

      async transaction(purchaseData){
        let data={
          items: purchaseData,
          totalPrice: this.state.totalPrice,
          paymentMethod: this.state.methodName,
          referenceTransactionNumber: this.state.referenceNumber
        }
        let request=await fetch('/customer/catalogue/buy', {method: 'POST', headers: {'Content-Type': 'application/json'}, 
        body: JSON.stringify(data)})
        let response=await request.json()
        if (response.message==='Successfull operation'){
          //Delete all the items of the shopping cart, and show the message of succesfull purchase
          eventBus.dispatch('sucessfullPurchase', null)
          alert('Compra exitosa!')
        } else if (response.message==='Failed operation'){
          //Show failed message...
          alert('Ha ocurrido un error. Intentelo de nuevo')
        } else if (response.message==='Producto(s) con cantidad insuficiente'){
          let productsNotAvailable=response.result.map(item=>{
            return item.name
          })
          alert(response.message + ' Los productos que cuya cantidad pedida no esta disponible son: '+productsNotAvailable.toString())
        } 
      }

      render(){
        return (
          <div className="modal fade" id="purchase" tabIndex="-1" aria-labelledby="exampleModalLabel" aria-hidden="true">
          <div className="modal-dialog">
    <div className="modal-content">
      <div className="modal-header">
        <h5 className="modal-title" id="exampleModalLabel">Confirmar compra</h5>
        <button type="button" className="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
      </div>
      <div className="modal-body" id="purchaseBody">
      	<p>Estos son los metodos de pago y los datos usados por nombre del comercio. Haz la respectiva transaccion con alguno de estos metodos
      	y luego confirma la transaccion</p>
        {this.props.paymentMethods.map(method=>{
          return <p key={method.name}>
          	       {method.name+' : '+method.referenceNumber}
          	     </p>
        })}
        <p>El precio total de tu compra es {this.state.totalPrice}</p>
        <p>Selecciona tu metodo de pago</p>
        <select className="form-control" id="exampleFormControlSelect1" value={this.state.methodName} onChange={this.changeMethodName}>
            {this.props.paymentMethods.map(method=>{
              return <option className="form-control" key={method.name}>{method.name}</option>
            })}
        </select>
        <p>Introduce el numero de referencia de tu transaccion</p>
        <input type="text" name="referenceNumberClient" value={this.state.referenceNumber} onChange={this.changeReferenceNumber}/>
      </div>
      <div className="modal-footer">
        <button type="button" className="btn btn-success" data-bs-dismiss="modal" id="confirmPurchase" onClick={this.confirm}>Confirmar compra</button>
        <button type="button" className="btn btn-danger" data-bs-dismiss="modal">Cerrar</button>
      </div>
    </div>
  </div>
</div>
        )
      }
    }

    //Ok... I need pass as props the financial information of the commerce to the purchase component, just that...
    let data=await getProducts()
    let paymentData=new paymentInformation()
    const cart=<ShoppingCart />
    const purchase=<Purchase paymentMethods={await paymentData.getData()}/>
    const searchProduct=<SearchProduct />
    const list=<List products={data.products} />
    ReactDOM.render(
      <div>
      	{searchProduct}
        {list}
        {cart}
        {purchase}
      </div>,
      document.getElementById('root')
    )
  })()
</script>

</body>
</html>